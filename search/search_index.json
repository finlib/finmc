{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"What is finmc?","text":"<p>The <code>finmc</code> package contains Monte-Carlo implementations of many financial models derived from a common interface class. This interface allows computation of instruments with european, and american payoffs, as well as path dependent calculations.</p> <p></p>"},{"location":"#why-do-we-need-a-common-interface","title":"Why do we need a common interface?","text":"<ul> <li>Shared utilities can be used for all models for tasks such as calcualting implied vol surface.</li> <li>Price Calculators can be model invariant.</li> <li>The interace is designed for high performance, even with a large number of paths.</li> </ul>"},{"location":"#getting-started","title":"Getting started.","text":"<p>Install it from PyPI</p> <pre><code>pip install finmc\n</code></pre> <p>This is an example of pricing a vanilla option using the local volatility model.</p> <pre><code>import numpy as np\nfrom finmc.models.localvol import LVMC\nfrom finmc.calc.option import opt_price_mc\n\n# Define Dataset with zero rate curve, and forward curve.\ndataset = {\n    \"MC\": {\"PATHS\": 100_000, \"TIMESTEP\": 1 / 250},\n    \"BASE\": \"USD\",\n    \"ASSETS\": {\n        \"USD\":(\"ZERO_RATES\", np.array([[2.0, 0.05]])),\n        \"SPX\": (\"FORWARD\", np.array([[0.0, 5500], [1.0, 5600]])),\n        },\n    \"LV\": {\"ASSET\": \"SPX\", \"VOL\": 0.3},\n}\n\nmodel = LVMC(dataset)\nprice = opt_price_mc(5500.0, 1.0, \"Call\", \"SPX\", model)\n</code></pre>"},{"location":"#learn-more","title":"Learn More","text":"<ul> <li>Dataset creation guide</li> <li>Models included in the package</li> </ul>"},{"location":"calculators/","title":"Calculators","text":"<p>This module contains shared calculators that can be used for all models, for calculations such as the price of vanilla options.</p> <p>Utility to calculate prices of european contracts from a MC Simulation model.</p>"},{"location":"calculators/#finmc.calc.option.opt_price_mc","title":"<code>opt_price_mc(strike, maturity, option_type, asset_name, model)</code>","text":"<p>Calculate the price of a Vanilla European Option using MC Simulation.</p> <p>Parameters:</p> Name Type Description Default <code>strike</code> <code>float</code> <p>The strike price of the option.</p> required <code>maturity</code> <code>float</code> <p>The time to maturity of the option in years.</p> required <code>option_type</code> <code>str</code> <p>The type of the option. Either \"Call\" or \"Put\".</p> required <code>asset_name</code> <code>str</code> <p>The name of the asset.</p> required <code>model</code> <code>MCBase</code> <p>The model used to simulate the asset price.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The price of the option.</p> <p>Examples:</p> <p>price = opt_price_mc(K, T, \"Call\", \"SPX\", model)</p> Source code in <code>finmc\\calc\\option.py</code> <pre><code>def opt_price_mc(\n    strike: float,\n    maturity: float,\n    option_type: str,\n    asset_name: str,\n    model: MCBase,\n) -&gt; float:\n    \"\"\"Calculate the price of a Vanilla European Option using MC Simulation.\n\n    Args:\n        strike: The strike price of the option.\n        maturity: The time to maturity of the option in years.\n        option_type: The type of the option. Either \"Call\" or \"Put\".\n        asset_name: The name of the asset.\n        model: The model used to simulate the asset price.\n\n    Returns:\n        The price of the option.\n\n    Examples:\n        price = opt_price_mc(K, T, \"Call\", \"SPX\", model)\n    \"\"\"\n\n    model.advance(maturity)\n    expiration_spots = model.get_value(asset_name)\n    df = model.get_df()\n\n    if option_type == \"Call\":\n        price = np.maximum(expiration_spots - strike, 0).mean() * df\n    else:\n        price = np.maximum(strike - expiration_spots, 0).mean() * df\n    return price\n</code></pre>"},{"location":"dataset/","title":"Dataset","text":"<p>The dataset for finmc models is a dictionary with the following components</p> <ul> <li>BASE String containing the name of the base asset, i.e. the currency in which the price is denominated. e.g. \"USD\".</li> <li>MC Dict containing common MC parameters.</li> <li>ASSETS Dict containing forwards of all assets in the model, including the base asset. See Forwards and Rates for more.</li> <li>{Model Name} Dict containing parameters specific to the model. See the models section for more.</li> </ul>"},{"location":"dataset/#mc-parameters","title":"MC Parameters","text":"<p>The MC section has the following parameters.</p> <ul> <li>PATHS: The number of Monte-Carlo paths.</li> <li>TIMESTEP: The incremental timestep of simulation (in years). </li> <li>SEED (Optional): The seed for the random number generator.</li> </ul> <p>e.g. <pre><code>\"MC\": {\n    \"PATHS\": 100_000,\n    \"TIMESTEP\": 1 / 250,\n    \"SEED\": 1,\n},\n</code></pre></p>"},{"location":"dataset/#complete-example","title":"Complete Example","text":"<pre><code>import numpy as np\n\ndataset = {\n    \"BASE\": \"USD\",\n    \"ASSETS\": {\n        \"USD\": (\"ZERO_RATES\", np.array([[2.0, 0.05]])),\n        \"SPX\": (\"FORWARD\", np.array([[0.0, 5500], [1.0, 5600]])),\n    },\n    \"MC\": {\n        \"PATHS\": 100_000,\n        \"TIMESTEP\": 1 / 250,\n        \"SEED\": 1,\n    },\n    \"HESTON\": {\n        \"ASSET\": \"SPX\",\n        \"INITIAL_VAR\": 0.015,\n        \"LONG_VAR\": 0.052,\n        \"VOL_OF_VAR\": 0.88,\n        \"MEANREV\": 2.78,\n        \"CORRELATION\": -0.85,\n    }\n}\n</code></pre>"},{"location":"forwards/","title":"Forwards","text":"<p>You can describe any asset forward using a two-column (N X 2) numpy array, where the first column is time, and the second represents forwards, e.g.</p> <pre><code>fwd_data = (\"FORWARD\", np.array([\n    [0.0, 5500],\n    [1.0, 5600],\n    [2.0, 5700]\n]))\n\ndataset = {\n    \"MC\": ...,\n    \"BASE\": \"USD\",\n    \"ASSETS\": {\n        \"USD\": ...,\n        \"SPX\": (\"FORWARD\", fwd_data),\n    },\n    ...model specific parameters\n}\n</code></pre> <p>or alternatively, using <code>np.column_stack</code> from two arrays</p> <pre><code>spot = 2900\ndiv_rate = 0.01\ntimes = np.array([0.0, 1.0, 2.0, 5.0])\nrates = np.array([0.04, 0.04, 0.045, 0.05])\nfwds = spot * np.exp((rates - div_rate) * times)\nfwd_data = (\"FORWARDS\", np.column_stack((times, fwds)))\n</code></pre> <p>For complete dataset see dataset</p>"},{"location":"rates/","title":"Rates","text":"<p>You can describe the base asset using a two-column (N X 2) numpy array, where the first column is time, and the second represents term zero rates, e.g.</p> <pre><code>[[1.   0.04]\n [2.   0.04]\n [5.   0.05]]\n</code></pre> <p>It can be created like</p> <pre><code>discount_data = (\"ZERO_RATES\", np.array([[1.0, .04], [5.0, 0.05]]))\ndataset = {\n    \"BASE\": \"USD\",\n    \"ASSETS\": {\"USD\": discount_data},\n}\n</code></pre> <p>Or alternatively, using <code>np.column_stack</code> from two arrays</p> <pre><code>times = np.array([1.0, 5.0])\nrates = np.array([0.04, 0.05])\ndiscount_data = (\"ZERO_RATES\", np.column_stack((times, rates)))\n</code></pre> <p>For complete dataset see dataset</p>"},{"location":"utilities/","title":"Utilities","text":"<p>(Image: See Heston Notebook)</p> <p>Utility to calculate implied volatility surface from a MC Simulation model.</p>"},{"location":"utilities/#finmc.calc.impliedvol.iv_surface_mc","title":"<code>iv_surface_mc(strikes, expirations, asset_name, model)</code>","text":"<p>Calculate the implied volatility surface using MC Simulation.</p> <p>Parameters:</p> Name Type Description Default <code>strikes</code> <p>The strikes of the options.</p> required <code>expirations</code> <p>The expirations of the options in years.</p> required <code>asset_name</code> <code>str</code> <p>The name of the asset.</p> required <code>model</code> <code>MCBase</code> <p>The model used to simulate the asset price.</p> required <p>Returns:</p> Type Description <p>A tuple containing the implied volatility surface, the ATM volatilities, and the forward prices.</p> <p>Examples:</p> <p>surface, atm_vols, fwds = iv_surface_mc(Ks, Ts, \"SPX\", model)</p> Source code in <code>finmc\\calc\\impliedvol.py</code> <pre><code>def iv_surface_mc(\n    strikes,\n    expirations,  # in years, increasing order\n    asset_name: str,\n    model: MCBase,\n):\n    \"\"\"Calculate the implied volatility surface using MC Simulation.\n\n    Args:\n        strikes: The strikes of the options.\n        expirations: The expirations of the options in years.\n        asset_name: The name of the asset.\n        model: The model used to simulate the asset price.\n\n    Returns:\n        A tuple containing the implied volatility surface, the ATM volatilities, and the forward prices.\n\n    Examples:\n        surface, atm_vols, fwds = iv_surface_mc(Ks, Ts, \"SPX\", model)\n    \"\"\"\n\n    iv_mat = np.zeros((len(expirations), len(strikes)))\n    iv_atm = []\n    fwds = []\n    for i, exp in enumerate(expirations):\n        model.advance(exp)\n        expiration_spots = model.get_value(asset_name)\n        fwd = expiration_spots.mean()\n\n        # Use a call option for strikes above forward, a put option otherwise\n        is_call = strikes &gt; fwd\n        is_call_c = is_call[..., None]  # Turn into a column vector\n\n        # calculate prices (value as of expiration date)\n        strikes_c = strikes[..., None]  # Turn into a column vector\n        pay = np.where(\n            is_call_c,\n            expiration_spots - strikes_c,\n            strikes_c - expiration_spots,\n        )\n        prices = np.maximum(pay, 0).mean(axis=1)\n\n        # calculate implied vols\n        iv_mat[i, :] = [\n            impliedvol(p, fwd, k, exp, ic)\n            for p, k, ic in zip(prices, strikes, is_call)\n        ]\n\n        # calculate atm vols\n        atm_call = np.maximum(expiration_spots - fwd, 0).mean()\n        # calculate implied vols and fwds\n        fwds.append(fwd)\n        iv_atm.append(impliedvol(atm_call, fwd, fwd, exp, True))\n    return iv_mat, np.array(iv_atm), np.array(fwds)\n</code></pre>"},{"location":"models/api/","title":"Model API","text":"<p>All models follow the interface defined in finmc.models.base.MCBase</p>"},{"location":"models/api/#finmc.models.base.MCBase","title":"<code>MCBase</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for a Monte-Carlo process.</p> Source code in <code>finmc\\models\\base.py</code> <pre><code>class MCBase(ABC):\n    \"\"\"Base class for a Monte-Carlo process.\"\"\"\n\n    stats: dict = {}\n\n    def __init__(self, dataset: dict) -&gt; None:\n        self.reset(dataset)\n\n    @abstractmethod\n    def reset(self, dataset: dict):\n        \"\"\"The derived class must implement this method to reset the state of the model\n        to time zero.\"\"\"\n        ...\n\n    def set_stat(self, key: str, val):\n        self.stats[key] = val\n\n    def get_value(self, unit):\n        \"\"\"Return the value of the asset at the current time,\n        if this asset is handled by the model, otherwise return None.\n        The return value is none, float, or an np array of floats.\"\"\"\n        return None\n\n    def get_df(self):\n        \"\"\"Return the discount factor at the current time.\n        The return value is a float, or an np array of floats.\"\"\"\n        ...\n\n    @abstractmethod\n    def advance(self, new_time: float):\n        \"\"\"The derived class must implement this method to advance the state of the model\n        to a new time. The model may do so in multiple time steps.\"\"\"\n        ...\n</code></pre>"},{"location":"models/api/#finmc.models.base.MCBase.reset","title":"<code>reset(dataset)</code>  <code>abstractmethod</code>","text":"<p>The derived class must implement this method to reset the state of the model to time zero.</p> Source code in <code>finmc\\models\\base.py</code> <pre><code>@abstractmethod\ndef reset(self, dataset: dict):\n    \"\"\"The derived class must implement this method to reset the state of the model\n    to time zero.\"\"\"\n    ...\n</code></pre>"},{"location":"models/api/#finmc.models.base.MCBase.get_value","title":"<code>get_value(unit)</code>","text":"<p>Return the value of the asset at the current time, if this asset is handled by the model, otherwise return None. The return value is none, float, or an np array of floats.</p> Source code in <code>finmc\\models\\base.py</code> <pre><code>def get_value(self, unit):\n    \"\"\"Return the value of the asset at the current time,\n    if this asset is handled by the model, otherwise return None.\n    The return value is none, float, or an np array of floats.\"\"\"\n    return None\n</code></pre>"},{"location":"models/api/#finmc.models.base.MCBase.get_df","title":"<code>get_df()</code>","text":"<p>Return the discount factor at the current time. The return value is a float, or an np array of floats.</p> Source code in <code>finmc\\models\\base.py</code> <pre><code>def get_df(self):\n    \"\"\"Return the discount factor at the current time.\n    The return value is a float, or an np array of floats.\"\"\"\n    ...\n</code></pre>"},{"location":"models/api/#finmc.models.base.MCBase.advance","title":"<code>advance(new_time)</code>  <code>abstractmethod</code>","text":"<p>The derived class must implement this method to advance the state of the model to a new time. The model may do so in multiple time steps.</p> Source code in <code>finmc\\models\\base.py</code> <pre><code>@abstractmethod\ndef advance(self, new_time: float):\n    \"\"\"The derived class must implement this method to advance the state of the model\n    to a new time. The model may do so in multiple time steps.\"\"\"\n    ...\n</code></pre>"},{"location":"models/api/#finmc.models.base.MCFixedStep","title":"<code>MCFixedStep</code>","text":"<p>               Bases: <code>MCBase</code></p> <p>A Monte-Carlo process which breaks down the 'advance' step into fixed time steps specified by the TIMESTEP parameter.</p> Source code in <code>finmc\\models\\base.py</code> <pre><code>class MCFixedStep(MCBase):\n    \"\"\"A Monte-Carlo process which breaks down the 'advance' step into fixed time steps\n    specified by the TIMESTEP parameter.\"\"\"\n\n    def advance(self, new_time):\n        while new_time &gt; self.cur_time + self.timestep:\n            self.advance_step(self.cur_time + self.timestep)\n        if new_time &gt; self.cur_time + 1e-10:\n            self.advance_step(new_time)\n\n    @abstractmethod\n    def advance_step(self, new_time: float):\n        \"\"\"The derived class must implement this method, which advances the model by a timestep equal to or\n        less than the TIMESTEP parameter.\"\"\"\n        ...\n</code></pre>"},{"location":"models/api/#finmc.models.base.MCFixedStep.advance_step","title":"<code>advance_step(new_time)</code>  <code>abstractmethod</code>","text":"<p>The derived class must implement this method, which advances the model by a timestep equal to or less than the TIMESTEP parameter.</p> Source code in <code>finmc\\models\\base.py</code> <pre><code>@abstractmethod\ndef advance_step(self, new_time: float):\n    \"\"\"The derived class must implement this method, which advances the model by a timestep equal to or\n    less than the TIMESTEP parameter.\"\"\"\n    ...\n</code></pre>"},{"location":"models/heston/","title":"Heston","text":""},{"location":"models/heston/#model","title":"Model","text":"<p>In the Heston model  the lognormal stock process \\(X_t\\) is given by,</p> \\[ dX_t = (\\mu - \\frac{\\nu_t}{2}) dt + \\sqrt \\nu_t dW_s \\] <p>and the variance follows the process $$ d \\nu_t = \\kappa (\\theta - \\nu_t) dt + \\xi \\sqrt \\nu_tdW_t $$</p> <p>where \\(dW_s\\) and \\(dW_t\\) are Wiener processes with correlation \\(\\rho\\).</p> <p>The model specific component in the dataset (<code>HESTON</code>) is a dict with five parameters, and the name of the asset:</p> <ul> <li>\\(\\nu_0\\), the initial variance (INITIAL_VAR).</li> <li>\\(\\theta\\), the long variance (LONG_VAR).</li> <li>\\(\\rho\\), the correlation (CORRELATION).</li> <li>\\(\\kappa\\), the mean reversion rate (MEANREV)).</li> <li>\\(\\xi\\), the volatility of the volatility (VOL_OF_VOL).</li> </ul>"},{"location":"models/heston/#example","title":"Example","text":"<pre><code>from finmc.models.heston import HestonMC\n\nheston_params = {\n    \"ASSET\": \"SPX\",\n    \"INITIAL_VAR\": 0.015,\n    \"LONG_VAR\": 0.052,\n    \"VOL_OF_VOL\": 0.88,\n    \"MEANREV\": 2.78,\n    \"CORRELATION\": -0.85,\n}\n</code></pre> <pre><code>dataset = {\n    \"MC\": {\"PATHS\": 100_000, \"TIMESTEP\": 1 / 250},\n    \"BASE\": \"USD\",\n    \"ASSETS\": {\n        \"USD\": (\"ZERO_RATES\", np.array([[2.0, 0.05]])),\n        \"SPX\": (\"FORWARD\", np.array([[0.0, 5500], [1.0, 5600]])),\n    },\n    \"HESTON\": heston_params\n}\nmodel = HestonMC(dataset)\nmodel.advance(1.0)\nspots = model.get_value(\"SPX\")\n</code></pre>"},{"location":"models/hullwhite/","title":"Hull-White","text":""},{"location":"models/hullwhite/#model","title":"Model","text":"<p>In the Hull White model, the short-rate follows the following process. $$ dr_t = [\\theta_t - a r_t]dt + \\sigma dW_t $$</p> <p>where \\(dW_t\\) is a Wiener process.</p> <p>The model specific component in the dataset (<code>HW</code>) is a dict with two parameters, and the name of the asset:</p> <ul> <li>\\(a\\), the mean reversion rate (MEANREV)).</li> <li>\\(\\sigma\\), the volatility of rate (VOL).</li> </ul> <p>\\(\\theta_t\\) is calibrated by the model from the zero rate curve.</p>"},{"location":"models/hullwhite/#example","title":"Example","text":"<pre><code>from finmc.models.hullwhite import HullWhiteMC\n\ndataset = {\n    \"MC\": {\"PATHS\": 100_000, \"TIMESTEP\": 1 / 250, \"SEED\": 1},\n    \"BASE\": \"USD\",\n    \"ASSETS\": {\"USD\": (\"ZERO_RATES\", np.array([[2.0, 0.05]]))},\n    \"HW\": {\n        \"ASSET\": \"USD\",\n        \"MEANREV\": 0.1,\n        \"VOL\": 0.03,\n    },\n}\n\nmodel = HullWhiteMC(dataset)\nmodel.advance(1.0)\ndiscount_factors = model.get_df()\n</code></pre>"},{"location":"models/localvol/","title":"Local-Vol","text":""},{"location":"models/localvol/#model","title":"Model","text":"<p>In the Local Vol model the lognormal stock process \\(X_t\\) is given by,</p> \\[ dX_t = (\\mu - \\frac{\\sigma_t^2}{2}) dt + \\sigma_t dW_s \\] <p>Where \\(\\sigma_t\\) is a function of \\(X_t\\) and \\(t\\).</p> <p>The model specific component in the dataset (<code>LV</code>) is a dict with two parameters <code>ASSET</code> and <code>VOL</code>.</p>"},{"location":"models/localvol/#examples","title":"Examples","text":""},{"location":"models/localvol/#constant-vol","title":"Constant Vol","text":"<p>This is an example with constant local volatility, in which case it reduces to the Black-Scholes Model.</p> <pre><code>from finmc.models.localvol import LVMC\n\nlv_params = {\"ASSET\": \"SPX\", \"VOL\": 0.015}\n\ndataset = {\n    \"MC\": {\"PATHS\": 100_000, \"TIMESTEP\": 1 / 250},\n    \"BASE\": \"USD\",\n    \"ASSETS\": {\n        \"USD\": (\"ZERO_RATES\", np.array([[2.0, 0.05]])),\n        \"SPX\": (\"FORWARD\", np.array([[0.0, 5500], [1.0, 5600]])),\n    },\n    \"LV\": lv_params\n}\nmodel = LVMC(dataset)\nmodel.advance(1.0)\nspots = model.get_value(\"SPX\")\n</code></pre>"},{"location":"models/localvol/#vol-function","title":"Vol Function","text":"<p><code>VOL</code> can be a function as shown below.</p> <pre><code>def volfn(points):\n    # t is float, x_vec is a np array\n    (t, x_vec) = points\n\n    at = 5.0 * t + .01\n    atm = 0.04 + 0.01 * np.exp(-at)\n    skew = -1.5 * (1 - np.exp(-at)) / at\n    return np.sqrt(np.maximum(0.001, atm + x_vec * skew))\n\n\nlv_params = {\"ASSET\": \"SPX\", \"VOL\": volfn}\n</code></pre>"},{"location":"models/localvol/#vol-interpolator","title":"Vol Interpolator","text":"<p><code>VOL</code> can be an interpolator as below</p> <pre><code>from scipy.interpolate import RegularGridInterpolator\n\ntimes = [0.01, 0.2, 1.0]\nstrikes = [-5.0, -0.5, -0.1, 0.0, 0.1, 0.5, 5.0]\nvols = np.array([\n    [2.713, 0.884, 0.442, 0.222, 0.032, 0.032, 0.032],\n    [2.187, 0.719, 0.372, 0.209, 0.032, 0.032, 0.032],\n    [1.237, 0.435, 0.264, 0.200, 0.101, 0.032, 0.032]\n])\nvolinterp = RegularGridInterpolator(\n    (times, strikes), vols, fill_value=None, bounds_error=False\n)\n\nlv_params = {\"ASSET\": \"SPX\", \"VOL\": volinterp}\n</code></pre>"}]}